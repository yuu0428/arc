<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circular Navigation Demo</title>
  <style>
    :root {
      --color-bg: #ffffff;
      --color-surface: #f5f7fa;
      --color-panel: #ffffff;
      --color-border: #e5e7eb;
      --color-text: #1f2933;
      --color-muted: #6b7280;
      --color-accent: #2563eb;
      --color-accent-soft: rgba(37, 99, 235, 0.12);
      --header-height: 72px;
      --transition-base: 200ms ease;
      --font-sans: 'Poppins', 'Segoe UI', system-ui, -apple-system, BlinkMacSystemFont, 'Hiragino Sans', 'Noto Sans JP', sans-serif;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font-sans);
      color: var(--color-text);
      background: var(--color-surface);
      min-height: 100vh;
      line-height: 1.6;
    }

    a {
      color: inherit;
      text-decoration: none;
    }

    main {
      padding-top: var(--header-height);
    }

    .site-header {
      position: fixed;
      inset: 0 0 auto 0;
      height: var(--header-height);
      background: var(--color-panel);
      border-bottom: 1px solid var(--color-border);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 60;
    }

    .header-inner {
      width: min(1040px, calc(100% - 40px));
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }

    .menu-toggle {
      position: absolute;
      left: 0;
      width: 46px;
      height: 46px;
      border-radius: 12px;
      border: 1px solid var(--color-border);
      background: var(--color-panel);
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 0;
      cursor: pointer;
      transition: border-color var(--transition-base), box-shadow var(--transition-base);
    }

    .menu-toggle:hover,
    .menu-toggle:focus-visible {
      border-color: var(--color-accent);
      box-shadow: 0 0 0 4px var(--color-accent-soft);
    }

    .menu-toggle:focus-visible {
      outline: none;
    }

    .menu-bar {
      width: 20px;
      height: 2px;
      border-radius: 999px;
      background: var(--color-text);
    }

    body.nav-open {
      overflow: hidden;
    }

    .circular-nav[hidden] {
      display: none;
    }

    .circular-nav {
      position: fixed;
      inset: 0;
      z-index: 90;
      opacity: 0;
      pointer-events: none;
      transition: opacity 260ms ease;
    }

    .circular-nav.is-visible {
      opacity: 1;
      pointer-events: auto;
    }

    .circular-nav__backdrop {
      position: absolute;
      inset: 0;
      background: rgba(9, 12, 20, 0.58);
      backdrop-filter: blur(6px);
    }

    .circular-nav__wheel-wrapper {
      position: absolute;
      left: 0;
      top: 50%;
      transform: translate(-18%, -50%);
      width: clamp(300px, 52vw, 460px);
      aspect-ratio: 1 / 1;
      display: grid;
      place-items: center;
      pointer-events: none;
    }

    @media (min-width: 720px) {
      .circular-nav__wheel-wrapper {
        transform: translate(-12%, -50%);
        width: clamp(320px, 48vw, 480px);
      }
    }

    .circular-nav__wheel {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      overflow: visible;
      pointer-events: auto;
      touch-action: none;
      cursor: grab;
      user-select: none;
      --nav-arc-start: 0deg;
      --nav-arc-span: 340deg;
    }

    .circular-nav__wheel.is-dragging {
      cursor: grabbing;
    }

    .circular-nav__wheel::before,
    .circular-nav__wheel::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      pointer-events: none;
    }

    .circular-nav__wheel::before {
      background:
        conic-gradient(
          from var(--nav-arc-start),
          rgba(18, 32, 58, 0.92) 0deg,
          rgba(37, 99, 235, 0.35) calc(var(--nav-arc-span) * 0.5),
          rgba(12, 20, 36, 0.9) var(--nav-arc-span),
          transparent var(--nav-arc-span) 360deg
        );
      box-shadow: 0 26px 80px rgba(9, 12, 20, 0.65);
      mask: radial-gradient(circle, transparent 0 44%, #000 46% 100%);
      -webkit-mask: radial-gradient(circle, transparent 0 44%, #000 46% 100%);
    }

    .circular-nav__wheel::after {
      inset: 10%;
      border-radius: 50%;
      background:
        conic-gradient(
          from var(--nav-arc-start),
          rgba(255, 255, 255, 0.2) 0deg,
          rgba(255, 255, 255, 0.08) calc(var(--nav-arc-span) * 0.65),
          rgba(255, 255, 255, 0.25) var(--nav-arc-span),
          transparent var(--nav-arc-span) 360deg
        );
      mask: radial-gradient(circle, transparent 0 48%, #000 50% 100%);
      -webkit-mask: radial-gradient(circle, transparent 0 48%, #000 50% 100%);
      z-index: -1;
    }

    .circular-nav__item {
      position: absolute;
      top: 50%;
      left: 50%;
      transform-origin: 50% 50%;
      padding: 10px 18px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.72);
      color: #f8fafc;
      border: 1px solid rgba(255, 255, 255, 0.18);
      font-size: 0.92rem;
      letter-spacing: 0.06em;
      font-weight: 500;
      white-space: nowrap;
      transition: transform 160ms ease, opacity 160ms ease, background 160ms ease, border-color 160ms ease, color 160ms ease, box-shadow 160ms ease;
      pointer-events: auto;
      user-select: none;
    }

    .circular-nav__item:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.35);
    }

    .circular-nav__item.is-active {
      background: var(--color-panel);
      color: var(--color-text);
      border-color: var(--color-accent);
      box-shadow: 0 16px 36px rgba(37, 99, 235, 0.35);
    }

    .circular-nav__close {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 38%;
      aspect-ratio: 1 / 1;
      transform: translate(-50%, -50%);
      border: none;
      border-radius: 50%;
      background: transparent;
      cursor: pointer;
      pointer-events: auto;
    }

    .circular-nav__close:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.35);
    }

    .demo-section {
      width: min(1040px, calc(100% - 40px));
      margin: 0 auto;
      padding: 80px 0;
      border-bottom: 1px solid var(--color-border);
    }

    .demo-section:last-of-type {
      border-bottom: none;
    }

    .demo-section h2 {
      margin-top: 0;
      font-size: clamp(1.8rem, 3vw, 2.4rem);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }

    .demo-section p {
      max-width: 60ch;
      color: var(--color-muted);
    }
  </style>
</head>
<body>
  <header class="site-header">
    <div class="header-inner">
      <button class="menu-toggle" aria-label="メニューを開く" aria-controls="circular-nav" aria-expanded="false">
        <span class="menu-bar"></span>
        <span class="menu-bar"></span>
        <span class="menu-bar"></span>
      </button>
      <a href="#top" class="site-logo" aria-label="トップへ戻る">
        Circular Nav
      </a>
    </div>
  </header>

  <div class="circular-nav" id="circular-nav" data-circular-nav role="dialog" aria-modal="true" aria-hidden="true" hidden>
    <div class="circular-nav__backdrop" data-nav-close></div>
    <div class="circular-nav__wheel-wrapper">
      <div class="circular-nav__wheel" data-nav-wheel>
        <button type="button" class="circular-nav__item" data-nav-item data-target="#top">Top</button>
        <button type="button" class="circular-nav__item" data-nav-item data-target="#about">About</button>
        <button type="button" class="circular-nav__item" data-nav-item data-target="#programs">Programs</button>
        <button type="button" class="circular-nav__item" data-nav-item data-target="#team">Team</button>
        <button type="button" class="circular-nav__item" data-nav-item data-target="#partners">Partners</button>
        <button type="button" class="circular-nav__item" data-nav-item data-target="#news">News</button>
        <button type="button" class="circular-nav__item" data-nav-item data-target="#contact">Contact</button>
      </div>
      <button type="button" class="circular-nav__close" aria-label="メニューを閉じる" data-nav-close></button>
    </div>
  </div>

  <main id="top">
    <section id="about" class="demo-section">
      <h2>About</h2>
      <p>このファイルは円形メガメニューのスタンドアロン実装です。HTML、CSS、JavaScript がひとつのファイルにまとまっているので、そのまま他サイトへ移植してカスタマイズできます。</p>
    </section>
    <section id="programs" class="demo-section">
      <h2>Programs</h2>
      <p>各 <code>data-nav-item</code> ボタンに <code>data-target</code> か <code>data-url</code> を指定するとクリック時の挙動を制御できます。スクロール対象がない場合は外部リンクにも対応しています。</p>
    </section>
    <section id="team" class="demo-section">
      <h2>Team</h2>
      <p>ドラック、ホイール、矢印キーで回転でき、最も上に位置する要素が自動でフォーカスされます。アクセシビリティを崩さずに演出を実現できます。</p>
    </section>
    <section id="partners" class="demo-section">
      <h2>Partners</h2>
      <p>レスポンシブに対応しており、ビュー幅に応じてホイールサイズが変化します。必要に応じて <code>--nav-arc-span</code> や配色をカスタマイズしてください。</p>
    </section>
    <section id="news" class="demo-section">
      <h2>News</h2>
      <p>複数の円形ナビゲーションを同一ページ内で使いたい場合は、マークアップと <code>id</code> を複製し、初期化関数を呼び出すだけです。</p>
    </section>
    <section id="contact" class="demo-section">
      <h2>Contact</h2>
      <p>ホイール中央の透明ボタン（<code>data-nav-close</code>）と背景をクリックするとメニューが閉じます。必要ならアイコンを配置して見た目を整えましょう。</p>
    </section>
  </main>

  <script>
    (() => {
      document.addEventListener('DOMContentLoaded', () => {
        initializeCircularNav();
      });

      function initializeCircularNav(root = document) {
        const overlay = root.querySelector('[data-circular-nav]');
        if (!overlay) return;

        const wheel = overlay.querySelector('[data-nav-wheel]');
        if (!wheel) return;

        const items = Array.from(wheel.querySelectorAll('[data-nav-item]'));
        if (!items.length) return;

        let toggle = null;
        if (overlay.id) {
          toggle = root.querySelector(`[aria-controls="${overlay.id}"]`);
        }
        if (!toggle) {
          toggle = root.querySelector('[data-circular-nav-toggle]');
        }
        if (!toggle) {
          toggle = root.querySelector('.menu-toggle');
        }
        if (!toggle) return;

        const menuState = { isOpen: false };

        const gapAngle = 20;
        const arcSpan = 360 - gapAngle;

        const navState = {
          rotation: 0,
          lastAngle: 0,
          pointerId: null,
          isDragging: false,
          startRotation: 0,
          didDrag: false,
          radius: 0,
          snapTimer: null,
          hideTimer: null,
          resizeTimer: null,
          baseAngles: [],
          step: 0,
          gapAngle,
          arcSpan,
        };

        if (items.length === 1) {
          navState.baseAngles = [0];
          navState.step = 360;
        } else {
          navState.step = 360 / items.length;
          navState.baseAngles = items.map((_, index) => index * navState.step);
          const desiredGapCenter = -90;
          const lastBaseAngle = navState.baseAngles[items.length - 1] ?? 0;
          const gapCenterWithoutRotation = lastBaseAngle + navState.step / 2;
          navState.rotation = normalizeAngle(desiredGapCenter - gapCenterWithoutRotation);
        }

        let lastFocused = null;

        const closeTargets = overlay.querySelectorAll('[data-nav-close]');

        toggle.addEventListener('click', () => {
          const expanded = toggle.getAttribute('aria-expanded') === 'true';
          if (expanded) {
            closeNav();
          } else {
            openNav();
          }
        });

        closeTargets.forEach((element) => {
          element.addEventListener('click', () => {
            closeNav();
          });
        });

        overlay.addEventListener('transitionend', (event) => {
          if (event.target !== overlay || event.propertyName !== 'opacity') return;
          if (!menuState.isOpen) {
            overlay.hidden = true;
            overlay.setAttribute('aria-hidden', 'true');
          }
        });

        wheel.addEventListener('pointerdown', handlePointerDown);
        wheel.addEventListener('pointermove', handlePointerMove);
        wheel.addEventListener('pointerup', handlePointerUp);
        wheel.addEventListener('pointercancel', handlePointerUp);
        wheel.addEventListener('pointerleave', handlePointerUp);
        wheel.addEventListener('wheel', handleWheel, { passive: false });

        window.addEventListener('resize', handleResize);

        items.forEach((item) => {
          item.addEventListener('click', (event) => {
            if (navState.didDrag) {
              navState.didDrag = false;
              return;
            }

            event.preventDefault();
            const targetSelector = item.dataset.target;
            const url = item.dataset.url;
            closeNav();

            window.setTimeout(() => {
              if (targetSelector) {
                const target = document.querySelector(targetSelector);
                if (target && typeof target.scrollIntoView === 'function') {
                  target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
              } else if (url) {
                window.open(url, '_blank', 'noopener');
              }
            }, 280);
          });
        });

        function openNav() {
          if (menuState.isOpen) return;
          lastFocused = document.activeElement instanceof HTMLElement ? document.activeElement : null;
          overlay.hidden = false;
          overlay.setAttribute('aria-hidden', 'false');
          requestAnimationFrame(() => {
            overlay.classList.add('is-visible');
            updateWheel(true);
          });
          menuState.isOpen = true;
          document.body.classList.add('nav-open');
          toggle.setAttribute('aria-expanded', 'true');
          toggle.setAttribute('aria-label', 'メニューを閉じる');
          focusActiveItem();
          document.addEventListener('keydown', handleKeydown);
        }

        function closeNav() {
          if (!menuState.isOpen) return;
          menuState.isOpen = false;
          overlay.classList.remove('is-visible');
          overlay.setAttribute('aria-hidden', 'true');
          toggle.setAttribute('aria-expanded', 'false');
          toggle.setAttribute('aria-label', 'メニューを開く');
          document.body.classList.remove('nav-open');
          document.removeEventListener('keydown', handleKeydown);
          wheel.classList.remove('is-dragging');
          navState.isDragging = false;
          navState.pointerId = null;
          navState.didDrag = false;
          window.clearTimeout(navState.snapTimer);
          window.clearTimeout(navState.resizeTimer);
          window.clearTimeout(navState.hideTimer);
          navState.snapTimer = null;
          navState.resizeTimer = null;
          navState.hideTimer = window.setTimeout(() => {
            if (!menuState.isOpen) {
              overlay.hidden = true;
              overlay.setAttribute('aria-hidden', 'true');
            }
          }, 260);

          if (lastFocused && typeof lastFocused.focus === 'function') {
            lastFocused.focus();
          } else {
            toggle.focus();
          }
        }

        function handleKeydown(event) {
          if (!menuState.isOpen) return;
          if (event.key === 'Escape') {
            event.preventDefault();
            closeNav();
            return;
          }

          if (event.key === 'ArrowRight' || event.key === 'ArrowDown') {
            event.preventDefault();
            rotateBy(-navState.step);
          } else if (event.key === 'ArrowLeft' || event.key === 'ArrowUp') {
            event.preventDefault();
            rotateBy(navState.step);
          }
        }

        function handlePointerDown(event) {
          if (event.pointerType === 'mouse' && event.button !== 0) {
            return;
          }

          navState.isDragging = true;
          navState.pointerId = event.pointerId;
          navState.startRotation = navState.rotation;
          navState.lastAngle = getPointerAngle(event);
          navState.didDrag = false;
          wheel.classList.add('is-dragging');
          if (wheel.setPointerCapture) {
            wheel.setPointerCapture(event.pointerId);
          }
        }

        function handlePointerMove(event) {
          if (!navState.isDragging || navState.pointerId !== event.pointerId) {
            return;
          }

          const angle = getPointerAngle(event);
          if (Number.isNaN(angle)) return;

          const delta = shortestAngle(navState.lastAngle, angle);
          navState.rotation += delta;
          navState.lastAngle = angle;

          if (Math.abs(navState.rotation - navState.startRotation) > navState.step * 0.2) {
            navState.didDrag = true;
          }

          updateWheel();
        }

        function handlePointerUp(event) {
          if (!navState.isDragging || (navState.pointerId !== null && navState.pointerId !== event.pointerId)) {
            return;
          }

          navState.isDragging = false;
          navState.pointerId = null;
          wheel.classList.remove('is-dragging');

          if (wheel.releasePointerCapture && event.pointerId !== undefined) {
            wheel.releasePointerCapture(event.pointerId);
          }

          snapToActive();
          navState.didDrag = false;
        }

        function handleWheel(event) {
          event.preventDefault();
          const delta = Math.abs(event.deltaY) > Math.abs(event.deltaX) ? event.deltaY : event.deltaX;
          if (Number.isNaN(delta)) return;

          navState.rotation += delta * 0.35;
          navState.didDrag = true;
          updateWheel();
          scheduleSnap();
        }

        function handleResize() {
          if (!menuState.isOpen) return;
          window.clearTimeout(navState.resizeTimer);
          navState.resizeTimer = window.setTimeout(() => {
            navState.radius = 0;
            updateWheel(true);
          }, 140);
        }

        function rotateBy(amount) {
          navState.rotation += amount;
          navState.didDrag = true;
          updateWheel();
          scheduleSnap();
        }

        function scheduleSnap() {
          window.clearTimeout(navState.snapTimer);
          navState.snapTimer = window.setTimeout(() => {
            snapToActive();
            navState.didDrag = false;
          }, 160);
        }

        function snapToActive() {
          const index = getActiveItemIndex();
          if (index === null) return;

          const targetAngle = navState.baseAngles[index];
          const current = normalizeAngle(targetAngle + navState.rotation);
          navState.rotation -= current;
          updateWheel();
          focusActiveItem();
        }

        function focusActiveItem() {
          const index = getActiveItemIndex();
          const item = items[index] || items[0];
          if (item) {
            item.focus({ preventScroll: true });
          }
        }

        function updateWheel(force = false) {
          const rect = wheel.getBoundingClientRect();
          if (!rect.width || !rect.height) {
            return;
          }

          if (force || !navState.radius) {
            navState.radius = Math.max(rect.width / 2 - 12, rect.width * 0.62);
          }

          const activeIndex = getActiveItemIndex();

          items.forEach((item, index) => {
            const baseAngle = navState.baseAngles[index] ?? 0;
            const angle = baseAngle + navState.rotation;
            const distance = Math.abs(normalizeAngle(angle));

            const proximity = Math.max(0, 1 - Math.min(distance / (navState.step * 1.1 || 1), 1));
            const scale = 0.84 + proximity * 0.22;
            const opacity = 0.52 + proximity * 0.42;

            const angleRad = (angle * Math.PI) / 180;
            const targetX = Math.cos(angleRad) * navState.radius;
            const targetY = Math.sin(angleRad) * navState.radius;
            const translateX = `calc(${targetX.toFixed(3)}px - 50%)`;
            const translateY = `calc(${targetY.toFixed(3)}px - 50%)`;

            item.style.transform = `translate(${translateX}, ${translateY}) scale(${scale.toFixed(3)})`;
            item.style.opacity = opacity.toFixed(3);
            item.style.zIndex = String(100 + Math.round(proximity * 100));
            item.classList.toggle('is-active', index === activeIndex);
            item.setAttribute('tabindex', index === activeIndex ? '0' : '-1');
          });

          const toPositive = (value) => ((value % 360) + 360) % 360;
          if (items.length >= 2) {
            const topAngle = toPositive(navState.baseAngles[0] + navState.rotation);
            const contactAngle = toPositive(navState.baseAngles[items.length - 1] + navState.rotation);
            const forwardDiff = (topAngle - contactAngle + 360) % 360;
            const gapCenter = (contactAngle + forwardDiff / 2) % 360;
            const arcStart = (gapCenter + navState.gapAngle / 2) % 360;
            const cssArcStart = (arcStart + 90) % 360;
            wheel.style.setProperty('--nav-arc-start', `${cssArcStart}deg`);
          } else {
            const cssArcStart = (toPositive(navState.rotation) + 90) % 360;
            wheel.style.setProperty('--nav-arc-start', `${cssArcStart}deg`);
          }

          wheel.style.setProperty('--nav-arc-span', `${navState.arcSpan}deg`);
        }

        function getActiveItemIndex() {
          let indexOfActive = 0;
          let minDistance = Number.POSITIVE_INFINITY;

          items.forEach((_, index) => {
            const angle = navState.baseAngles[index] + navState.rotation;
            const distance = Math.abs(normalizeAngle(angle));
            if (distance < minDistance) {
              minDistance = distance;
              indexOfActive = index;
            }
          });

          return indexOfActive;
        }

        function getPointerAngle(event) {
          const rect = wheel.getBoundingClientRect();
          const cx = rect.left + rect.width / 2;
          const cy = rect.top + rect.height / 2;
          const radians = Math.atan2(event.clientY - cy, event.clientX - cx);
          return radians * (180 / Math.PI);
        }

        function shortestAngle(from, to) {
          let diff = to - from;
          while (diff > 180) diff -= 360;
          while (diff < -180) diff += 360;
          return diff;
        }

        function normalizeAngle(angle) {
          const normalized = ((angle % 360) + 360) % 360;
          return normalized > 180 ? normalized - 360 : normalized;
        }

        overlay.circularNav = {
          open: openNav,
          close: closeNav,
        };
      }
    })();
  </script>
</body>
</html>
